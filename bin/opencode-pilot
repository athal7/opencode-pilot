#!/usr/bin/env node
/**
 * opencode-pilot - CLI for opencode-pilot automation daemon
 *
 * Commands:
 *   start       Start the polling service
 *   status      Show service status
 *   config      Validate and show configuration
 *   test-source Test a polling source
 *   test-mapping Test field mappings
 *   help        Show help
 */

import { fileURLToPath } from "url";
import { dirname, join } from "path";
import { existsSync, readFileSync, writeFileSync, unlinkSync, mkdirSync } from "fs";
import { execSync, spawn } from "child_process";
import os from "os";
import YAML from "yaml";

// Get script directory for relative imports
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Find service directory - check multiple locations for homebrew compatibility
function findServiceDir() {
  const candidates = [
    join(__dirname, "..", "service"),      // Development: bin/../service
    join(__dirname, "..", "libexec"),      // Homebrew: bin/../libexec
  ];
  for (const dir of candidates) {
    if (existsSync(join(dir, "server.js"))) {
      return dir;
    }
  }
  return candidates[0];
}

const serviceDir = findServiceDir();

// Paths
const PILOT_CONFIG_DIR = join(os.homedir(), ".config/opencode/pilot");
const PILOT_CONFIG_FILE = join(PILOT_CONFIG_DIR, "config.yaml");
const PILOT_TEMPLATES_DIR = join(PILOT_CONFIG_DIR, "templates");
const PILOT_PID_FILE = join(PILOT_CONFIG_DIR, "pilot.pid");

// Default port
const DEFAULT_PORT = 4097;

/**
 * Write PID file
 */
function writePidFile() {
  try {
    mkdirSync(PILOT_CONFIG_DIR, { recursive: true });
    writeFileSync(PILOT_PID_FILE, String(process.pid));
  } catch (err) {
    console.warn(`[opencode-pilot] Could not write PID file: ${err.message}`);
  }
}

/**
 * Remove PID file
 */
function removePidFile() {
  try {
    if (existsSync(PILOT_PID_FILE)) {
      unlinkSync(PILOT_PID_FILE);
    }
  } catch {
    // Ignore errors on cleanup
  }
}

/**
 * Read PID from file
 * @returns {number|null} PID or null if not found/invalid
 */
function readPidFile() {
  try {
    if (existsSync(PILOT_PID_FILE)) {
      const content = readFileSync(PILOT_PID_FILE, "utf8").trim();
      const pid = parseInt(content, 10);
      if (!isNaN(pid) && pid > 0) {
        return pid;
      }
    }
  } catch {
    // Ignore errors
  }
  return null;
}

/**
 * Check if a process is running
 * @param {number} pid - Process ID
 * @returns {boolean} True if process is running
 */
function isProcessRunning(pid) {
  try {
    // Signal 0 doesn't kill, just checks if process exists
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}

/**
 * Load port from config file
 * @returns {number} Port number
 */
function getPortFromConfig() {
  try {
    if (existsSync(PILOT_CONFIG_FILE)) {
      const content = readFileSync(PILOT_CONFIG_FILE, "utf8");
      const config = YAML.parse(content);
      if (config?.port && typeof config.port === "number") {
        return config.port;
      }
    }
  } catch {
    // Ignore errors, use default
  }
  return DEFAULT_PORT;
}

// Parse command line arguments
function parseArgs(args) {
  const result = {
    command: null,
    subcommand: null,
    flags: {},
    positional: [],
  };

  let i = 0;
  while (i < args.length) {
    const arg = args[i];

    if (arg.startsWith("--")) {
      const key = arg.slice(2);
      if (i + 1 < args.length && !args[i + 1].startsWith("-")) {
        result.flags[key] = args[i + 1];
        i += 2;
      } else {
        result.flags[key] = true;
        i += 1;
      }
    } else if (arg.startsWith("-")) {
      const key = arg.slice(1);
      result.flags[key] = true;
      i += 1;
    } else if (!result.command) {
      result.command = arg;
      i += 1;
    } else if (!result.subcommand) {
      result.subcommand = arg;
      i += 1;
    } else {
      result.positional.push(arg);
      i += 1;
    }
  }

  return result;
}

// Help text
function showHelp() {
  console.log(`opencode-pilot - Automation daemon for OpenCode

Usage:
  opencode-pilot <command> [options]

Commands:
  start                Start the polling service (foreground)
  stop                 Stop the running service
  status               Show service status and version
  config               Validate and show configuration
  clear                Clear processed state entries
  logs                 Show debug log output
  test-source NAME     Test a source by fetching items and showing mappings
  test-mapping MCP     Test field mappings with sample JSON input
  help                 Show this help message

Clear options:
  --all                Clear all processed entries
  --source NAME        Clear entries for a specific source
  --item ID            Clear a specific item
  --expired            Clear only expired entries (uses configured TTL)

Logs options:
  --path               Print the log file path and exit
  --lines N            Print last N lines (default: 50)
  --follow             Follow the log file (like tail -f)

The service handles:
- Polling for GitHub/Linear issues to work on
- Spawning OpenCode sessions for ready items

Examples:
  opencode-pilot start                   # Start service (foreground)
  opencode-pilot stop                    # Stop the service
  opencode-pilot status                  # Check status and version
  opencode-pilot config                  # Validate and show config
  opencode-pilot clear --all             # Clear all processed state
  opencode-pilot clear --expired         # Clear expired entries
  opencode-pilot logs                    # Show last 50 log lines
  opencode-pilot logs --lines 100        # Show last 100 log lines
  opencode-pilot logs --follow           # Follow the log in real time
  opencode-pilot logs --path             # Print the log file path
  opencode-pilot test-source my-issues   # Test a source
  echo '{"url":"https://linear.app/team/issue/PROJ-123/title"}' | opencode-pilot test-mapping linear
`);
}

// ============================================================================
// Start Command
// ============================================================================

async function startCommand() {
  // Import and run the service directly
  const serverPath = join(serviceDir, "server.js");
  if (!existsSync(serverPath)) {
    console.error("ERROR: Could not find server.js");
    console.error(`Expected at: ${serverPath}`);
    process.exit(1);
  }

  console.log("[opencode-pilot] Starting polling service...");
  
  // Write PID file
  writePidFile();
  
  // Dynamic import of the service module
  const { startService, stopService } = await import(serverPath);
  
  const config = {
    httpPort: getPortFromConfig(),
  };
  
  const service = await startService(config);
  
  // Handle graceful shutdown
  const shutdown = async (signal) => {
    console.log(`[opencode-pilot] Received ${signal}, shutting down...`);
    removePidFile();
    await stopService(service);
    process.exit(0);
  };
  
  process.on("SIGTERM", () => shutdown("SIGTERM"));
  process.on("SIGINT", () => shutdown("SIGINT"));
  
  // Keep running until signal received
  await new Promise(() => {});
}

// ============================================================================
// Stop Command
// ============================================================================

function stopCommand() {
  const pid = readPidFile();
  
  if (!pid) {
    console.log("Service is not running (no PID file found)");
    process.exit(0);
  }
  
  if (!isProcessRunning(pid)) {
    console.log(`Service is not running (stale PID file for pid ${pid})`);
    removePidFile();
    process.exit(0);
  }
  
  console.log(`Stopping opencode-pilot (pid ${pid})...`);
  
  try {
    process.kill(pid, "SIGTERM");
    
    // Wait for process to exit (up to 5 seconds)
    let attempts = 0;
    const maxAttempts = 50;
    const checkInterval = 100;
    
    const waitForExit = () => {
      if (!isProcessRunning(pid)) {
        console.log("Service stopped");
        process.exit(0);
      }
      
      attempts++;
      if (attempts >= maxAttempts) {
        console.log("Service did not stop gracefully, sending SIGKILL...");
        try {
          process.kill(pid, "SIGKILL");
        } catch {
          // Process may have exited
        }
        removePidFile();
        console.log("Service killed");
        process.exit(0);
      }
      
      setTimeout(waitForExit, checkInterval);
    };
    
    setTimeout(waitForExit, checkInterval);
  } catch (err) {
    if (err.code === "ESRCH") {
      console.log("Service is not running");
      removePidFile();
    } else {
      console.error(`Failed to stop service: ${err.message}`);
      process.exit(1);
    }
  }
}

// ============================================================================
// Status Command
// ============================================================================

async function statusCommand() {
  const { getVersion } = await import(join(serviceDir, "version.js"));
  const version = getVersion();
  console.log(`opencode-pilot v${version}`);
  console.log("=".repeat(`opencode-pilot v${version}`.length));
  console.log("");

  // Service running? Check if HTTP responds
  const servicePort = getPortFromConfig();
  
  try {
    const res = execSync(`curl -s -o /dev/null -w "%{http_code}" http://localhost:${servicePort}/health`, { encoding: "utf8", timeout: 2000 });
    if (res.trim() === "200") {
      console.log("Service: running");
    } else {
      console.log("Service: not responding (run: opencode-pilot start)");
    }
  } catch {
    console.log("Service: not running (run: opencode-pilot start)");
  }

  // Polling configuration
  console.log("");
  console.log("Configuration:");
  if (existsSync(PILOT_CONFIG_FILE)) {
    console.log(`  config.yaml: ${PILOT_CONFIG_FILE}`);
  } else {
    console.log(`  config.yaml: not found at ${PILOT_CONFIG_FILE}`);
    console.log("  polling: disabled");
  }
}

// ============================================================================
// Config Command
// ============================================================================

async function configCommand() {
  console.log("opencode-pilot configuration");
  console.log("============================");
  console.log("");

  // Check config file exists
  if (!existsSync(PILOT_CONFIG_FILE)) {
    console.log(`Config file not found: ${PILOT_CONFIG_FILE}`);
    console.log("");
    console.log("Create one by copying the example:");
    console.log("  cp node_modules/opencode-pilot/examples/config.yaml ~/.config/opencode/pilot/config.yaml");
    process.exit(1);
  }

  // Load and parse config
  let config;
  try {
    const { default: YAML } = await import("yaml");
    const content = readFileSync(PILOT_CONFIG_FILE, "utf8");
    config = YAML.parse(content);
    console.log("✓ Config file parsed successfully");
  } catch (err) {
    console.log(`✗ Failed to parse config: ${err.message}`);
    process.exit(1);
  }

  const defaults = config.defaults || {};

  // Validate repos section
  console.log("");
  console.log("Repos:");
  const repos = config.repos || {};
  const repoKeys = Object.keys(repos);
  if (repoKeys.length === 0) {
    console.log("  (none configured)");
  } else {
    for (const key of repoKeys) {
      const repo = repos[key];
      const isPrefix = key.endsWith("/");
      const path = repo.path || repo.repo_path;
      const expandedPath = path ? path.replace("~", os.homedir()).replace("{repo}", "<repo>") : "<not set>";
      const pathExists = path && !path.includes("{repo}") ? existsSync(path.replace("~", os.homedir())) : null;
      
      if (pathExists === false) {
        console.log(`  ✗ ${key}: ${expandedPath} (path not found)`);
      } else if (isPrefix) {
        console.log(`  ${key}: ${expandedPath} (prefix)`);
      } else {
        console.log(`  ✓ ${key}: ${expandedPath}`);
      }
    }
  }

  // Validate sources section (use getSources to expand presets)
  console.log("");
  console.log("Sources:");
  const { loadRepoConfig, getSources } = await import(join(serviceDir, "repo-config.js"));
  loadRepoConfig(PILOT_CONFIG_FILE);
  
  let sources;
  try {
    sources = getSources();
  } catch (err) {
    console.log(`  ✗ Failed to load sources: ${err.message}`);
    sources = [];
  }
  
  if (sources.length === 0) {
    console.log("  (none configured)");
  } else {
    for (const source of sources) {
      const name = source.name || "<unnamed>";
      const tool = source.tool;
      
      if (!tool || (!tool.command && (!tool.mcp || !tool.name))) {
        console.log(`  ✗ ${name}: missing tool.command or tool.mcp/tool.name`);
        continue;
      }
      
      const toolDesc = tool.command 
        ? `cli: ${Array.isArray(tool.command) ? tool.command[0] : tool.command.split(' ')[0]}`
        : `${tool.mcp}/${tool.name}`;
      const itemId = source.item?.id;
      if (!itemId) {
        console.log(`  ⚠ ${name}: ${toolDesc} (no item.id template)`);
      } else {
        console.log(`  ✓ ${name}: ${toolDesc}`);
      }
      
      // Show prompt and agent
      const prompt = source.prompt || defaults.prompt || "default";
      const agent = source.agent || defaults.agent;
      console.log(`      prompt: ${prompt}`);
      if (agent) console.log(`      agent: ${agent}`);
      
      // Show repo resolution - interpolate template with configured repos
      const configuredRepos = Object.keys(config.repos || {});
      if (source.repos) {
        // Explicit repos filter - check if it's all configured repos
        const isAll = configuredRepos.length > 0 && 
          source.repos.length === configuredRepos.length &&
          source.repos.every(r => configuredRepos.includes(r));
        if (isAll) {
          console.log(`      repos: all`);
        } else {
          for (const repo of source.repos) {
            console.log(`      repo: ${repo}`);
          }
        }
      } else if (source.repo && source.repo.includes("{")) {
        // Template like {repository_full_name} - matches all configured repos
        if (configuredRepos.length > 0) {
          console.log(`      repos: all`);
        } else {
          console.log(`      repos: (none configured)`);
        }
      } else if (source.repo) {
        // Static repo
        console.log(`      repo: ${source.repo}`);
      } else if (source.working_dir) {
        console.log(`      working_dir: ${source.working_dir}`);
      }
      // Don't show working_dir if it's just the default
    }
  }

  // Validate templates
  console.log("");
  console.log("Templates:");
  if (!existsSync(PILOT_TEMPLATES_DIR)) {
    console.log(`  ⚠ Templates directory not found: ${PILOT_TEMPLATES_DIR}`);
  } else {
    const { readdirSync } = await import("fs");
    const templates = readdirSync(PILOT_TEMPLATES_DIR).filter(f => f.endsWith(".md"));
    if (templates.length === 0) {
      console.log("  (no templates found)");
    } else {
      for (const t of templates) {
        console.log(`  ✓ ${t.replace(".md", "")}`);
      }
    }
    
    // Check if referenced templates exist
    const referencedTemplates = new Set();
    if (defaults.prompt) referencedTemplates.add(defaults.prompt);
    for (const repo of Object.values(repos)) {
      if (repo.prompt) referencedTemplates.add(repo.prompt);
    }
    for (const source of sources) {
      if (source.prompt) referencedTemplates.add(source.prompt);
    }
    
    const existingTemplates = new Set(templates.map(t => t.replace(".md", "")));
    for (const ref of referencedTemplates) {
      if (!existingTemplates.has(ref)) {
        console.log(`  ✗ ${ref} (referenced but not found)`);
      }
    }
  }

  console.log("");
  console.log("Configuration valid!");
}

// ============================================================================
// Test Source Command
// ============================================================================

async function testSourceCommand(sourceName) {
  // Load sources using getSources() to expand presets
  const { loadRepoConfig, getSources } = await import(join(serviceDir, "repo-config.js"));
  loadRepoConfig(PILOT_CONFIG_FILE);
  
  let sources;
  try {
    sources = getSources();
  } catch (err) {
    console.error(`Failed to load sources: ${err.message}`);
    process.exit(1);
  }

  if (!sourceName) {
    console.error("Usage: opencode-pilot test-source <source-name>");
    console.error("");
    console.error("Available sources:");
    
    if (sources.length === 0) {
      console.error("  (no sources configured)");
    } else {
      for (const s of sources) {
        console.error(`  ${s.name}`);
      }
    }
    process.exit(1);
  }

  console.log(`Testing source: ${sourceName}`);
  console.log("=".repeat(40));
  console.log("");

  // Find source
  const source = sources.find(s => s.name === sourceName);
  
  if (!source) {
    console.error(`Source not found: ${sourceName}`);
    console.error("");
    console.error("Available sources:");
    for (const s of sources) {
      console.error(`  ${s.name}`);
    }
    process.exit(1);
  }

  // Show source config
  console.log("Source Configuration:");
  console.log(`  name: ${source.name}`);
  console.log(`  tool.mcp: ${source.tool?.mcp || "(not set)"}`);
  console.log(`  tool.name: ${source.tool?.name || "(not set)"}`);
  console.log(`  args: ${JSON.stringify(source.args || {})}`);
  console.log(`  item.id: ${source.item?.id || "(not set)"}`);
  if (source.repo) console.log(`  repo: ${source.repo}`);
  if (source.working_dir) console.log(`  working_dir: ${source.working_dir}`);
  if (source.prompt) console.log(`  prompt: ${source.prompt}`);
  if (source.agent) console.log(`  agent: ${source.agent}`);

  // Show mappings (using getToolProviderConfig which includes preset defaults)
  const { getToolProviderConfig } = await import(join(serviceDir, "repo-config.js"));
  const provider = source.tool?.mcp;
  const toolProviderConfig = getToolProviderConfig(provider);
  const mappings = toolProviderConfig?.mappings;
  
  console.log("");
  console.log("Field Mappings:");
  if (mappings && Object.keys(mappings).length > 0) {
    for (const [target, sourcePath] of Object.entries(mappings)) {
      console.log(`  ${target} ← ${sourcePath}`);
    }
  } else {
    console.log(`  (no mappings for provider '${provider}')`);
  }
  
  if (toolProviderConfig?.response_key) {
    console.log(`  response_key: ${toolProviderConfig.response_key}`);
  }

  // Fetch items
  console.log("");
  console.log("Fetching items...");
  
  try {
    // Import poller
    const pollerPath = join(serviceDir, "poller.js");
    const { pollGenericSource, applyMappings } = await import(pollerPath);
    
    // Fetch items with tool provider config (includes mappings and response_key)
    const items = await pollGenericSource(source, { toolProviderConfig });
    
    console.log(`Found ${items.length} item(s)`);
    console.log("");

    // Show first few items
    const maxItems = 3;
    for (let i = 0; i < Math.min(items.length, maxItems); i++) {
      const item = items[i];
      console.log(`Item ${i + 1}:`);
      console.log("  Raw fields:");
      for (const [key, value] of Object.entries(item)) {
        const displayValue = typeof value === "object" 
          ? JSON.stringify(value) 
          : String(value);
        const truncated = displayValue.length > 60 
          ? displayValue.substring(0, 57) + "..." 
          : displayValue;
        console.log(`    ${key}: ${truncated}`);
      }
      
      // Apply mappings
      if (mappings) {
        const mapped = applyMappings(item, mappings);
        console.log("  After mappings:");
        // Show mapped fields that are different
        for (const [target] of Object.entries(mappings)) {
          if (mapped[target] !== undefined) {
            const displayValue = typeof mapped[target] === "object"
              ? JSON.stringify(mapped[target])
              : String(mapped[target]);
            const truncated = displayValue.length > 60
              ? displayValue.substring(0, 57) + "..."
              : displayValue;
            console.log(`    ${target}: ${truncated}`);
          }
        }
      }
      console.log("");
    }

    if (items.length > maxItems) {
      console.log(`... and ${items.length - maxItems} more item(s)`);
    }

  } catch (err) {
    console.error(`Error fetching items: ${err.message}`);
    if (err.stack) {
      console.error("");
      console.error("Stack trace:");
      console.error(err.stack);
    }
    process.exit(1);
  }
}

// ============================================================================
// Test Mapping Command
// ============================================================================

async function testMappingCommand(mcpName) {
  if (!mcpName) {
    console.error("Usage: echo '<json>' | opencode-pilot test-mapping <mcp-name>");
    console.error("");
    console.error("Test field mappings by piping JSON and specifying the MCP server name.");
    console.error("");
    console.error("Example:");
    console.error('  echo \'{"url":"https://linear.app/team/issue/PROJ-123/title","title":"Fix bug"}\' | opencode-pilot test-mapping linear');
    console.error("");
    
    // Show available tools with mappings
    const { loadRepoConfig, getToolMappings } = await import(join(serviceDir, "repo-config.js"));
    loadRepoConfig(PILOT_CONFIG_FILE);
    
    console.error("Configured MCP servers with mappings:");
    for (const name of ["github", "linear"]) {
      const mappings = getToolMappings(name);
      if (mappings && Object.keys(mappings).length > 0) {
        console.error(`  ${name}:`);
        for (const [target, source] of Object.entries(mappings)) {
          console.error(`    ${target} ← ${source}`);
        }
      }
    }
    process.exit(1);
  }

  // Read JSON from stdin
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  const input = Buffer.concat(chunks).toString().trim();
  
  if (!input) {
    console.error("Error: No JSON input provided. Pipe JSON to stdin.");
    console.error("");
    console.error("Example:");
    console.error('  echo \'{"url":"https://linear.app/team/issue/PROJ-123/title"}\' | opencode-pilot test-mapping linear');
    process.exit(1);
  }

  let item;
  try {
    item = JSON.parse(input);
  } catch (err) {
    console.error(`Error parsing JSON: ${err.message}`);
    process.exit(1);
  }

  // Load mappings
  const { loadRepoConfig, getToolMappings } = await import(join(serviceDir, "repo-config.js"));
  const { applyMappings } = await import(join(serviceDir, "poller.js"));
  
  loadRepoConfig(PILOT_CONFIG_FILE);
  const mappings = getToolMappings(mcpName);

  if (!mappings || Object.keys(mappings).length === 0) {
    console.error(`No mappings configured for MCP server: ${mcpName}`);
    console.error("");
    console.error("Add mappings to your config.yaml:");
    console.error("  tools:");
    console.error(`    ${mcpName}:`);
    console.error("      mappings:");
    console.error('        number: "url:/([A-Z0-9]+-[0-9]+)/"');
    process.exit(1);
  }

  console.log("Input:");
  for (const [key, value] of Object.entries(item)) {
    const displayValue = typeof value === "object" ? JSON.stringify(value) : String(value);
    const truncated = displayValue.length > 60 ? displayValue.substring(0, 57) + "..." : displayValue;
    console.log(`  ${key}: ${truncated}`);
  }
  console.log("");

  console.log(`Mappings (${mcpName}):`);
  for (const [target, source] of Object.entries(mappings)) {
    console.log(`  ${target} ← ${source}`);
  }
  console.log("");

  const mapped = applyMappings(item, mappings);

  console.log("Result:");
  for (const [target] of Object.entries(mappings)) {
    const value = mapped[target];
    if (value !== undefined) {
      console.log(`  ${target}: ${value}`);
    } else {
      console.log(`  ${target}: (undefined - no match)`);
    }
  }
}

// ============================================================================
// Clear Command
// ============================================================================

async function clearCommand(flags) {
  try {
    const { createPoller } = await import(join(serviceDir, "poller.js"));
    const { loadRepoConfig, getCleanupTtlDays } = await import(join(serviceDir, "repo-config.js"));
    
    // Load config for TTL settings
    if (existsSync(PILOT_CONFIG_FILE)) {
      loadRepoConfig(PILOT_CONFIG_FILE);
    }
    
    const poller = createPoller();
    const beforeCount = poller.getProcessedCount();
    
    if (flags.all) {
      poller.clearState();
      console.log(`Cleared all ${beforeCount} processed entries`);
    } else if (flags.source) {
      const removed = poller.clearBySource(flags.source);
      console.log(`Cleared ${removed} entries for source: ${flags.source}`);
    } else if (flags.item) {
      if (poller.isProcessed(flags.item)) {
        poller.clearProcessed(flags.item);
        console.log(`Cleared item: ${flags.item}`);
      } else {
        console.log(`Item not found in processed state: ${flags.item}`);
      }
    } else if (flags.expired) {
      const ttlDays = getCleanupTtlDays();
      const removed = poller.cleanupExpired(ttlDays);
      console.log(`Cleared ${removed} entries older than ${ttlDays} days`);
    } else {
      // No flags - show current state summary
      console.log("Poll state summary:");
      console.log(`  Total entries: ${beforeCount}`);
      console.log(`  State file: ~/.config/opencode/pilot/poll-state.json`);
      console.log("");
      console.log("Usage:");
      console.log("  opencode-pilot clear --all           Clear all entries");
      console.log("  opencode-pilot clear --source NAME   Clear entries for source");
      console.log("  opencode-pilot clear --item ID       Clear specific item");
      console.log("  opencode-pilot clear --expired       Clear expired entries");
    }
  } catch (err) {
    console.error(`Error: ${err.message}`);
    console.error("The state file may be corrupted. Try: opencode-pilot clear --all");
    process.exit(1);
  }
}

// ============================================================================
// Logs Command
// ============================================================================

// Default log path (mirrors service/logger.js)
const DEFAULT_LOG_PATH = join(os.homedir(), ".local", "share", "opencode-pilot", "debug.log");

/**
 * Resolve the debug log file path.
 * Can be overridden via PILOT_LOG_PATH env var (used in tests).
 */
function getLogPath() {
  return process.env.PILOT_LOG_PATH || DEFAULT_LOG_PATH;
}

/**
 * Read the last `n` lines from a file synchronously.
 * Returns an empty array if the file does not exist.
 */
function tailLines(filePath, n) {
  if (!existsSync(filePath)) return [];
  const content = readFileSync(filePath, "utf8");
  const lines = content.split("\n");
  // Remove trailing empty line produced by a file ending with \n
  if (lines[lines.length - 1] === "") lines.pop();
  return lines.slice(-n);
}

/**
 * Parse a --lines flag value, falling back to `defaultN` for missing/invalid input.
 */
function parseLineCount(value, defaultN) {
  if (value === undefined || value === true || value === false) return defaultN;
  const n = parseInt(value, 10);
  return Number.isFinite(n) && n > 0 ? n : defaultN;
}

async function logsCommand(flags) {
  const logPath = getLogPath();

  // --path: just print the path and exit
  if (flags.path) {
    console.log(logPath);
    return;
  }

  // --follow: stream the file using tail -f
  if (flags.follow) {
    if (!existsSync(logPath)) {
      console.log(`No log file yet. Enable debug logging with PILOT_DEBUG=true.`);
      console.log(`Log path: ${logPath}`);
      return;
    }
    const lineCount = parseLineCount(flags.lines, 50);
    // Use system `tail -f` for reliable follow behaviour
    const tail = spawn("tail", ["-f", "-n", String(lineCount), logPath], {
      stdio: ["ignore", "inherit", "inherit"],
    });
    await new Promise((resolve, reject) => {
      tail.on("error", reject);
      tail.on("close", resolve);
    });
    return;
  }

  // Default: print last N lines
  const n = parseLineCount(flags.lines, 50);
  if (!existsSync(logPath)) {
    console.log(`No log file found. Debug logging is enabled via PILOT_DEBUG=true.`);
    console.log(`Log path: ${logPath}`);
    return;
  }

  const lines = tailLines(logPath, n);
  if (lines.length === 0) {
    console.log(`Log file is empty: ${logPath}`);
    return;
  }
  console.log(lines.join("\n"));
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  const { command, subcommand } = parseArgs(args);

  if (!command || command === "help") {
    showHelp();
    return;
  }

  switch (command) {
    case "start":
      await startCommand();
      break;

    case "stop":
      stopCommand();
      break;

    case "status":
      await statusCommand();
      break;

    case "config":
      await configCommand();
      break;

    case "clear":
      await clearCommand(parseArgs(args).flags);
      break;

    case "logs":
      await logsCommand(parseArgs(args).flags);
      break;

    case "test-source":
      await testSourceCommand(subcommand);
      break;

    case "test-mapping":
      await testMappingCommand(subcommand);
      break;

    default:
      console.error(`Unknown command: ${command}`);
      console.error("");
      showHelp();
      process.exit(1);
  }
}

main().catch((err) => {
  console.error("Error:", err.message);
  process.exit(1);
});
