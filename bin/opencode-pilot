#!/usr/bin/env node
/**
 * opencode-pilot - CLI for opencode-pilot automation
 *
 * Commands:
 *   setup       Copy plugin files and configure OpenCode
 *   status      Show installation and service status
 *   help        Show help
 */

import { fileURLToPath } from "url";
import { dirname, join } from "path";
import { existsSync, readFileSync, writeFileSync, mkdirSync, cpSync, rmSync } from "fs";
import { execSync } from "child_process";
import os from "os";

// Get script directory for relative imports
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Find service directory - check multiple locations for homebrew compatibility
function findServiceDir() {
  const candidates = [
    join(__dirname, "..", "service"),      // Development: bin/../service
    join(__dirname, "..", "libexec"),      // Homebrew: bin/../libexec
  ];
  for (const dir of candidates) {
    if (existsSync(join(dir, "server.js"))) {
      return dir;
    }
  }
  return candidates[0];
}

// Find plugin directory
function findPluginDir() {
  const candidates = [
    join(__dirname, "..", "plugin"),                        // Development
    join(__dirname, "..", "lib", "opencode-pilot", "plugin"), // Homebrew
  ];
  for (const dir of candidates) {
    if (existsSync(join(dir, "index.js"))) {
      return dir;
    }
  }
  return null;
}

const serviceDir = findServiceDir();

// Paths
const OPENCODE_CONFIG_DIR = join(os.homedir(), ".config/opencode");
const PLUGIN_NAME = "opencode-pilot";
const PLUGIN_DEST = join(OPENCODE_CONFIG_DIR, "plugins", PLUGIN_NAME);
const OPENCODE_CONFIG_FILE = join(OPENCODE_CONFIG_DIR, "opencode.json");
const PILOT_CONFIG_FILE = join(os.homedir(), ".config/opencode-pilot/config.yaml");
const PILOT_TEMPLATES_DIR = join(os.homedir(), ".config/opencode-pilot/templates");

// Parse command line arguments
function parseArgs(args) {
  const result = {
    command: null,
    subcommand: null,
    flags: {},
    positional: [],
  };

  let i = 0;
  while (i < args.length) {
    const arg = args[i];

    if (arg.startsWith("--")) {
      const key = arg.slice(2);
      if (i + 1 < args.length && !args[i + 1].startsWith("-")) {
        result.flags[key] = args[i + 1];
        i += 2;
      } else {
        result.flags[key] = true;
        i += 1;
      }
    } else if (arg.startsWith("-")) {
      const key = arg.slice(1);
      result.flags[key] = true;
      i += 1;
    } else if (!result.command) {
      result.command = arg;
      i += 1;
    } else if (!result.subcommand) {
      result.subcommand = arg;
      i += 1;
    } else {
      result.positional.push(arg);
      i += 1;
    }
  }

  return result;
}

// Help text
function showHelp() {
  console.log(`opencode-pilot - Automation layer for OpenCode

Usage:
  opencode-pilot <command> [options]

Commands:
  start                Start the callback service (foreground)
  setup                Copy plugin files and configure OpenCode
  status               Show installation and service status
  config               Validate and show configuration
  test-source NAME     Test a source by fetching items and showing mappings
  test-mapping MCP     Test field mappings with sample JSON input
  help                 Show this help message

The service handles:
- Notification callbacks from ntfy
- Polling for GitHub/Linear issues to work on

Examples:
  opencode-pilot start                   # Start service (foreground)
  opencode-pilot setup                   # Initial setup
  opencode-pilot status                  # Check status
  opencode-pilot config                  # Validate and show config
  opencode-pilot test-source my-issues   # Test a source
  echo '{"url":"https://linear.app/team/issue/PROJ-123/title"}' | opencode-pilot test-mapping linear
`);
}

// ============================================================================
// Start Command
// ============================================================================

async function startCommand() {
  // Import and run the service directly
  const serverPath = join(serviceDir, "server.js");
  if (!existsSync(serverPath)) {
    console.error("ERROR: Could not find server.js");
    console.error(`Expected at: ${serverPath}`);
    process.exit(1);
  }

  console.log("[opencode-pilot] Starting callback service...");
  
  // Dynamic import of the service module
  const { startService, stopService } = await import(serverPath);
  
  const config = {
    httpPort: parseInt(process.env.NTFY_CALLBACK_PORT || "4097", 10),
    socketPath: process.env.NTFY_SOCKET_PATH || "/tmp/opencode-pilot.sock",
  };
  
  const service = await startService(config);
  
  // Handle graceful shutdown
  process.on("SIGTERM", async () => {
    console.log("[opencode-pilot] Received SIGTERM, shutting down...");
    await stopService(service);
    process.exit(0);
  });
  
  process.on("SIGINT", async () => {
    console.log("[opencode-pilot] Received SIGINT, shutting down...");
    await stopService(service);
    process.exit(0);
  });
  
  // Keep running until signal received
  await new Promise(() => {});
}

// ============================================================================
// Setup Command
// ============================================================================

async function setupCommand() {
  console.log("Setting up opencode-pilot...");
  console.log("");

  const pluginSource = findPluginDir();
  if (!pluginSource) {
    console.error("ERROR: Could not find plugin source files");
    console.error("Install via: brew install athal7/tap/opencode-pilot");
    process.exit(1);
  }

  console.log(`Source: ${pluginSource}`);
  console.log(`Destination: ${PLUGIN_DEST}`);
  console.log("");

  // Backup existing config
  if (existsSync(OPENCODE_CONFIG_FILE)) {
    const backupFile = `${OPENCODE_CONFIG_FILE}.backup.${Date.now()}`;
    try {
      cpSync(OPENCODE_CONFIG_FILE, backupFile);
      console.log(`Backup created: ${backupFile}`);
    } catch (err) {
      console.error("ERROR: Failed to create backup of opencode.json");
      process.exit(1);
    }
  }

  // Copy plugin files
  mkdirSync(join(OPENCODE_CONFIG_DIR, "plugins"), { recursive: true });
  if (existsSync(PLUGIN_DEST)) {
    rmSync(PLUGIN_DEST, { recursive: true });
  }
  cpSync(pluginSource, PLUGIN_DEST, { recursive: true });
  console.log("Plugin files copied.");

  // Update opencode.json
  let config = {};
  if (existsSync(OPENCODE_CONFIG_FILE)) {
    try {
      config = JSON.parse(readFileSync(OPENCODE_CONFIG_FILE, "utf8"));
    } catch {
      config = {};
    }
  }

  config.plugin = config.plugin || [];
  const alreadyRegistered = config.plugin.some(p => p.includes(`plugins/${PLUGIN_NAME}`));

  if (alreadyRegistered) {
    console.log("Plugin already in opencode.json");
  } else {
    config.plugin.push(PLUGIN_DEST);
    const tempFile = `${OPENCODE_CONFIG_FILE}.tmp`;
    writeFileSync(tempFile, JSON.stringify(config, null, 2) + "\n");
    const { renameSync } = await import("fs");
    renameSync(tempFile, OPENCODE_CONFIG_FILE);
    console.log("Added plugin to opencode.json");
  }

  // Try to restart service
  try {
    execSync("brew services restart opencode-pilot", { stdio: "pipe" });
    console.log("");
    console.log("Service restarted.");
  } catch {
    // Not installed via brew or service not available
  }

  console.log("");
  console.log("Setup complete!");
  console.log("");
  console.log("Next steps:");
  console.log("  1. Edit ~/.config/opencode-pilot/config.yaml");
  console.log("  2. Run: opencode-pilot start");
}

// ============================================================================
// Status Command
// ============================================================================

function getConfigValue(envVar, configKey, defaultValue = "") {
  // Check env var first
  if (process.env[envVar]) {
    return process.env[envVar];
  }

  // Check config file
  if (existsSync(PILOT_CONFIG_FILE)) {
    try {
      const config = JSON.parse(readFileSync(PILOT_CONFIG_FILE, "utf8"));
      if (config[configKey] !== undefined && config[configKey] !== "") {
        return config[configKey];
      }
    } catch {
      // Ignore
    }
  }

  return defaultValue;
}

function statusCommand() {
  console.log("opencode-pilot status");
  console.log("=====================");
  console.log("");

  // Plugin installed?
  if (existsSync(PLUGIN_DEST)) {
    console.log(`Plugin: installed at ${PLUGIN_DEST}`);
  } else {
    console.log("Plugin: NOT INSTALLED (run: opencode-pilot setup)");
  }

  // Config?
  if (existsSync(OPENCODE_CONFIG_FILE)) {
    try {
      const config = JSON.parse(readFileSync(OPENCODE_CONFIG_FILE, "utf8"));
      const registered = (config.plugin || []).some(p => p.includes(`plugins/${PLUGIN_NAME}`));
      if (registered) {
        console.log("Config: plugin registered in opencode.json");
      } else {
        console.log("Config: plugin NOT in opencode.json");
      }
    } catch {
      console.log("Config: could not parse opencode.json");
    }
  } else {
    console.log("Config: opencode.json not found");
  }

  // Service running? Check if socket exists and HTTP responds
  const socketPath = "/tmp/opencode-pilot.sock";
  const servicePort = getConfigValue("NTFY_CALLBACK_PORT", "callbackPort", "4097");
  
  if (existsSync(socketPath)) {
    // Socket exists, try health check
    try {
      const res = execSync(`curl -s -o /dev/null -w "%{http_code}" http://localhost:${servicePort}/health`, { encoding: "utf8", timeout: 2000 });
      if (res.trim() === "200") {
        console.log("Service: running");
      } else {
        console.log("Service: socket exists but not responding (run: opencode-pilot start)");
      }
    } catch {
      console.log("Service: socket exists but health check failed");
    }
  } else {
    console.log("Service: not running (run: opencode-pilot start)");
  }

  // Notification configuration
  console.log("");
  console.log("Notification Configuration:");

  const topic = getConfigValue("NTFY_TOPIC", "topic", "");
  const server = getConfigValue("NTFY_SERVER", "server", "https://ntfy.sh");
  const callbackHost = getConfigValue("NTFY_CALLBACK_HOST", "callbackHost", "");
  const callbackPort = getConfigValue("NTFY_CALLBACK_PORT", "callbackPort", "4097");

  console.log(`  topic: ${topic || "<not set>"}`);
  console.log(`  server: ${server}`);
  console.log(`  callbackHost: ${callbackHost || "<not set>"}`);
  console.log(`  callbackPort: ${callbackPort}`);

  // Polling configuration
  console.log("");
  console.log("Polling Configuration:");
  if (existsSync(PILOT_CONFIG_FILE)) {
    console.log(`  config.yaml: ${PILOT_CONFIG_FILE}`);
    console.log("  polling: enabled (handled by service)");
  } else {
    console.log(`  config.yaml: not found at ${PILOT_CONFIG_FILE}`);
    console.log("  polling: disabled");
  }
}

// ============================================================================
// Config Command
// ============================================================================

async function configCommand() {
  console.log("opencode-pilot configuration");
  console.log("============================");
  console.log("");

  // Check config file exists
  if (!existsSync(PILOT_CONFIG_FILE)) {
    console.log(`Config file not found: ${PILOT_CONFIG_FILE}`);
    console.log("");
    console.log("Create one by copying the example:");
    console.log("  cp node_modules/opencode-pilot/examples/config.yaml ~/.config/opencode-pilot/config.yaml");
    process.exit(1);
  }

  // Load and parse config
  let config;
  try {
    const { default: YAML } = await import("yaml");
    const content = readFileSync(PILOT_CONFIG_FILE, "utf8");
    config = YAML.parse(content);
    console.log("✓ Config file parsed successfully");
  } catch (err) {
    console.log(`✗ Failed to parse config: ${err.message}`);
    process.exit(1);
  }

  // Validate notifications section
  console.log("");
  console.log("Notifications:");
  const notifications = config.notifications || {};
  if (notifications.topic) {
    console.log(`  ✓ topic: ${notifications.topic.substring(0, 8)}...`);
  } else {
    console.log("  ✗ topic: not set (required for notifications)");
  }
  console.log(`  server: ${notifications.server || "https://ntfy.sh"}`);
  if (notifications.callback_host) {
    console.log(`  ✓ callback_host: ${notifications.callback_host}`);
  } else {
    console.log("  ⚠ callback_host: not set (interactive notifications disabled)");
  }

  // Validate defaults section
  console.log("");
  console.log("Defaults:");
  const defaults = config.defaults || {};
  console.log(`  working_dir: ${defaults.working_dir || "~"}`);
  console.log(`  prompt: ${defaults.prompt || "default"}`);
  if (defaults.agent) console.log(`  agent: ${defaults.agent}`);
  if (defaults.model) console.log(`  model: ${defaults.model}`);

  // Validate repos section
  console.log("");
  console.log("Repos:");
  const repos = config.repos || {};
  const repoKeys = Object.keys(repos);
  if (repoKeys.length === 0) {
    console.log("  (none configured)");
  } else {
    for (const key of repoKeys) {
      const repo = repos[key];
      const isPrefix = key.endsWith("/");
      const path = repo.path || repo.repo_path;
      const expandedPath = path ? path.replace("~", os.homedir()).replace("{repo}", "<repo>") : "<not set>";
      const pathExists = path && !path.includes("{repo}") ? existsSync(path.replace("~", os.homedir())) : null;
      
      if (pathExists === false) {
        console.log(`  ✗ ${key}: ${expandedPath} (path not found)`);
      } else if (isPrefix) {
        console.log(`  ${key}: ${expandedPath} (prefix)`);
      } else {
        console.log(`  ✓ ${key}: ${expandedPath}`);
      }
    }
  }

  // Validate sources section
  console.log("");
  console.log("Sources:");
  const sources = config.sources || [];
  if (sources.length === 0) {
    console.log("  (none configured)");
  } else {
    for (const source of sources) {
      const name = source.name || "<unnamed>";
      const tool = source.tool;
      
      if (!tool || !tool.mcp || !tool.name) {
        console.log(`  ✗ ${name}: missing tool.mcp or tool.name`);
        continue;
      }
      
      const itemId = source.item?.id;
      if (!itemId) {
        console.log(`  ⚠ ${name}: ${tool.mcp}/${tool.name} (no item.id template)`);
      } else {
        console.log(`  ✓ ${name}: ${tool.mcp}/${tool.name}`);
      }
      
      // Show repo resolution
      if (source.repo) {
        console.log(`      repo: ${source.repo}`);
      } else if (source.repos) {
        console.log(`      repos: ${Array.isArray(source.repos) ? source.repos.join(", ") : JSON.stringify(source.repos)}`);
      } else if (source.working_dir) {
        console.log(`      working_dir: ${source.working_dir}`);
      } else {
        console.log(`      (uses defaults.working_dir)`);
      }
    }
  }

  // Validate templates
  console.log("");
  console.log("Templates:");
  if (!existsSync(PILOT_TEMPLATES_DIR)) {
    console.log(`  ⚠ Templates directory not found: ${PILOT_TEMPLATES_DIR}`);
  } else {
    const { readdirSync } = await import("fs");
    const templates = readdirSync(PILOT_TEMPLATES_DIR).filter(f => f.endsWith(".md"));
    if (templates.length === 0) {
      console.log("  (no templates found)");
    } else {
      for (const t of templates) {
        console.log(`  ✓ ${t.replace(".md", "")}`);
      }
    }
    
    // Check if referenced templates exist
    const referencedTemplates = new Set();
    if (defaults.prompt) referencedTemplates.add(defaults.prompt);
    for (const repo of Object.values(repos)) {
      if (repo.prompt) referencedTemplates.add(repo.prompt);
    }
    for (const source of sources) {
      if (source.prompt) referencedTemplates.add(source.prompt);
    }
    
    const existingTemplates = new Set(templates.map(t => t.replace(".md", "")));
    for (const ref of referencedTemplates) {
      if (!existingTemplates.has(ref)) {
        console.log(`  ✗ ${ref} (referenced but not found)`);
      }
    }
  }

  console.log("");
  console.log("Configuration valid!");
}

// ============================================================================
// Test Source Command
// ============================================================================

async function testSourceCommand(sourceName) {
  if (!sourceName) {
    console.error("Usage: opencode-pilot test-source <source-name>");
    console.error("");
    console.error("Available sources:");
    
    // Load and show available sources
    if (existsSync(PILOT_CONFIG_FILE)) {
      try {
        const { default: YAML } = await import("yaml");
        const content = readFileSync(PILOT_CONFIG_FILE, "utf8");
        const config = YAML.parse(content);
        const sources = config.sources || [];
        if (sources.length === 0) {
          console.error("  (no sources configured)");
        } else {
          for (const s of sources) {
            console.error(`  ${s.name}`);
          }
        }
      } catch (err) {
        console.error(`  Error loading config: ${err.message}`);
      }
    } else {
      console.error("  (config file not found)");
    }
    process.exit(1);
  }

  console.log(`Testing source: ${sourceName}`);
  console.log("=".repeat(40));
  console.log("");

  // Load config
  if (!existsSync(PILOT_CONFIG_FILE)) {
    console.error(`Config file not found: ${PILOT_CONFIG_FILE}`);
    process.exit(1);
  }

  const { default: YAML } = await import("yaml");
  const content = readFileSync(PILOT_CONFIG_FILE, "utf8");
  const config = YAML.parse(content);

  // Find source
  const sources = config.sources || [];
  const source = sources.find(s => s.name === sourceName);
  
  if (!source) {
    console.error(`Source not found: ${sourceName}`);
    console.error("");
    console.error("Available sources:");
    for (const s of sources) {
      console.error(`  ${s.name}`);
    }
    process.exit(1);
  }

  // Show source config
  console.log("Source Configuration:");
  console.log(`  name: ${source.name}`);
  console.log(`  tool.mcp: ${source.tool?.mcp || "(not set)"}`);
  console.log(`  tool.name: ${source.tool?.name || "(not set)"}`);
  console.log(`  args: ${JSON.stringify(source.args || {})}`);
  console.log(`  item.id: ${source.item?.id || "(not set)"}`);
  if (source.repo) console.log(`  repo: ${source.repo}`);
  if (source.working_dir) console.log(`  working_dir: ${source.working_dir}`);
  if (source.prompt) console.log(`  prompt: ${source.prompt}`);
  if (source.agent) console.log(`  agent: ${source.agent}`);

  // Show mappings
  const tools = config.tools || {};
  const provider = source.tool?.mcp;
  const mappings = tools[provider]?.mappings;
  
  console.log("");
  console.log("Field Mappings:");
  if (mappings) {
    for (const [target, sourcePath] of Object.entries(mappings)) {
      console.log(`  ${target} ← ${sourcePath}`);
    }
  } else {
    console.log(`  (no mappings configured for provider '${provider}')`);
  }

  // Fetch items
  console.log("");
  console.log("Fetching items...");
  
  try {
    // Import poller
    const pollerPath = join(serviceDir, "poller.js");
    const { pollGenericSource, applyMappings } = await import(pollerPath);
    const { getToolMappings } = await import(join(serviceDir, "repo-config.js"));
    
    // Fetch items with mappings applied
    const items = await pollGenericSource(source, { mappings });
    
    console.log(`Found ${items.length} item(s)`);
    console.log("");

    // Show first few items
    const maxItems = 3;
    for (let i = 0; i < Math.min(items.length, maxItems); i++) {
      const item = items[i];
      console.log(`Item ${i + 1}:`);
      console.log("  Raw fields:");
      for (const [key, value] of Object.entries(item)) {
        const displayValue = typeof value === "object" 
          ? JSON.stringify(value) 
          : String(value);
        const truncated = displayValue.length > 60 
          ? displayValue.substring(0, 57) + "..." 
          : displayValue;
        console.log(`    ${key}: ${truncated}`);
      }
      
      // Apply mappings
      if (mappings) {
        const mapped = applyMappings(item, mappings);
        console.log("  After mappings:");
        // Show mapped fields that are different
        for (const [target] of Object.entries(mappings)) {
          if (mapped[target] !== undefined) {
            const displayValue = typeof mapped[target] === "object"
              ? JSON.stringify(mapped[target])
              : String(mapped[target]);
            const truncated = displayValue.length > 60
              ? displayValue.substring(0, 57) + "..."
              : displayValue;
            console.log(`    ${target}: ${truncated}`);
          }
        }
      }
      console.log("");
    }

    if (items.length > maxItems) {
      console.log(`... and ${items.length - maxItems} more item(s)`);
    }

  } catch (err) {
    console.error(`Error fetching items: ${err.message}`);
    if (err.stack) {
      console.error("");
      console.error("Stack trace:");
      console.error(err.stack);
    }
    process.exit(1);
  }
}

// ============================================================================
// Test Mapping Command
// ============================================================================

async function testMappingCommand(mcpName) {
  if (!mcpName) {
    console.error("Usage: echo '<json>' | opencode-pilot test-mapping <mcp-name>");
    console.error("");
    console.error("Test field mappings by piping JSON and specifying the MCP server name.");
    console.error("");
    console.error("Example:");
    console.error('  echo \'{"url":"https://linear.app/team/issue/PROJ-123/title","title":"Fix bug"}\' | opencode-pilot test-mapping linear');
    console.error("");
    
    // Show available tools with mappings
    const { loadRepoConfig, getToolMappings } = await import(join(serviceDir, "repo-config.js"));
    loadRepoConfig(PILOT_CONFIG_FILE);
    
    console.error("Configured MCP servers with mappings:");
    for (const name of ["github", "linear"]) {
      const mappings = getToolMappings(name);
      if (mappings && Object.keys(mappings).length > 0) {
        console.error(`  ${name}:`);
        for (const [target, source] of Object.entries(mappings)) {
          console.error(`    ${target} ← ${source}`);
        }
      }
    }
    process.exit(1);
  }

  // Read JSON from stdin
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  const input = Buffer.concat(chunks).toString().trim();
  
  if (!input) {
    console.error("Error: No JSON input provided. Pipe JSON to stdin.");
    console.error("");
    console.error("Example:");
    console.error('  echo \'{"url":"https://linear.app/team/issue/PROJ-123/title"}\' | opencode-pilot test-mapping linear');
    process.exit(1);
  }

  let item;
  try {
    item = JSON.parse(input);
  } catch (err) {
    console.error(`Error parsing JSON: ${err.message}`);
    process.exit(1);
  }

  // Load mappings
  const { loadRepoConfig, getToolMappings } = await import(join(serviceDir, "repo-config.js"));
  const { applyMappings } = await import(join(serviceDir, "poller.js"));
  
  loadRepoConfig(PILOT_CONFIG_FILE);
  const mappings = getToolMappings(mcpName);

  if (!mappings || Object.keys(mappings).length === 0) {
    console.error(`No mappings configured for MCP server: ${mcpName}`);
    console.error("");
    console.error("Add mappings to your config.yaml:");
    console.error("  tools:");
    console.error(`    ${mcpName}:`);
    console.error("      mappings:");
    console.error('        number: "url:/([A-Z0-9]+-[0-9]+)/"');
    process.exit(1);
  }

  console.log("Input:");
  for (const [key, value] of Object.entries(item)) {
    const displayValue = typeof value === "object" ? JSON.stringify(value) : String(value);
    const truncated = displayValue.length > 60 ? displayValue.substring(0, 57) + "..." : displayValue;
    console.log(`  ${key}: ${truncated}`);
  }
  console.log("");

  console.log(`Mappings (${mcpName}):`);
  for (const [target, source] of Object.entries(mappings)) {
    console.log(`  ${target} ← ${source}`);
  }
  console.log("");

  const mapped = applyMappings(item, mappings);

  console.log("Result:");
  for (const [target] of Object.entries(mappings)) {
    const value = mapped[target];
    if (value !== undefined) {
      console.log(`  ${target}: ${value}`);
    } else {
      console.log(`  ${target}: (undefined - no match)`);
    }
  }
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  const { command, subcommand, flags } = parseArgs(args);

  if (!command || command === "help") {
    showHelp();
    return;
  }

  switch (command) {
    case "start":
      await startCommand();
      break;

    case "setup":
      await setupCommand();
      break;

    case "status":
      statusCommand();
      break;

    case "config":
      await configCommand();
      break;

    case "test-source":
      await testSourceCommand(subcommand);
      break;

    case "test-mapping":
      await testMappingCommand(subcommand);
      break;

    default:
      console.error(`Unknown command: ${command}`);
      console.error("");
      showHelp();
      process.exit(1);
  }
}

main().catch((err) => {
  console.error("Error:", err.message);
  process.exit(1);
});
