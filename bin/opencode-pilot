#!/usr/bin/env node
/**
 * opencode-pilot - CLI for opencode-pilot automation daemon
 *
 * Commands:
 *   start       Start the polling service
 *   status      Show service status
 *   config      Validate and show configuration
 *   test-source Test a polling source
 *   test-mapping Test field mappings
 *   help        Show help
 */

import { fileURLToPath } from "url";
import { dirname, join } from "path";
import { existsSync, readFileSync } from "fs";
import { execSync } from "child_process";
import os from "os";
import YAML from "yaml";

// Get script directory for relative imports
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Find service directory - check multiple locations for homebrew compatibility
function findServiceDir() {
  const candidates = [
    join(__dirname, "..", "service"),      // Development: bin/../service
    join(__dirname, "..", "libexec"),      // Homebrew: bin/../libexec
  ];
  for (const dir of candidates) {
    if (existsSync(join(dir, "server.js"))) {
      return dir;
    }
  }
  return candidates[0];
}

const serviceDir = findServiceDir();

// Paths
const PILOT_CONFIG_FILE = join(os.homedir(), ".config/opencode/pilot/config.yaml");
const PILOT_TEMPLATES_DIR = join(os.homedir(), ".config/opencode/pilot/templates");

// Default port
const DEFAULT_PORT = 4097;

/**
 * Load port from config file
 * @returns {number} Port number
 */
function getPortFromConfig() {
  try {
    if (existsSync(PILOT_CONFIG_FILE)) {
      const content = readFileSync(PILOT_CONFIG_FILE, "utf8");
      const config = YAML.parse(content);
      if (config?.port && typeof config.port === "number") {
        return config.port;
      }
    }
  } catch {
    // Ignore errors, use default
  }
  return DEFAULT_PORT;
}

// Parse command line arguments
function parseArgs(args) {
  const result = {
    command: null,
    subcommand: null,
    flags: {},
    positional: [],
  };

  let i = 0;
  while (i < args.length) {
    const arg = args[i];

    if (arg.startsWith("--")) {
      const key = arg.slice(2);
      if (i + 1 < args.length && !args[i + 1].startsWith("-")) {
        result.flags[key] = args[i + 1];
        i += 2;
      } else {
        result.flags[key] = true;
        i += 1;
      }
    } else if (arg.startsWith("-")) {
      const key = arg.slice(1);
      result.flags[key] = true;
      i += 1;
    } else if (!result.command) {
      result.command = arg;
      i += 1;
    } else if (!result.subcommand) {
      result.subcommand = arg;
      i += 1;
    } else {
      result.positional.push(arg);
      i += 1;
    }
  }

  return result;
}

// Help text
function showHelp() {
  console.log(`opencode-pilot - Automation daemon for OpenCode

Usage:
  opencode-pilot <command> [options]

Commands:
  start                Start the polling service (foreground)
  status               Show service status
  config               Validate and show configuration
  clear                Clear processed state entries
  test-source NAME     Test a source by fetching items and showing mappings
  test-mapping MCP     Test field mappings with sample JSON input
  help                 Show this help message

Clear options:
  --all                Clear all processed entries
  --source NAME        Clear entries for a specific source
  --item ID            Clear a specific item
  --expired            Clear only expired entries (uses configured TTL)

The service handles:
- Polling for GitHub/Linear issues to work on
- Spawning OpenCode sessions for ready items

Examples:
  opencode-pilot start                   # Start service (foreground)
  opencode-pilot status                  # Check status
  opencode-pilot config                  # Validate and show config
  opencode-pilot clear --all             # Clear all processed state
  opencode-pilot clear --expired         # Clear expired entries
  opencode-pilot test-source my-issues   # Test a source
  echo '{"url":"https://linear.app/team/issue/PROJ-123/title"}' | opencode-pilot test-mapping linear
`);
}

// ============================================================================
// Start Command
// ============================================================================

async function startCommand() {
  // Import and run the service directly
  const serverPath = join(serviceDir, "server.js");
  if (!existsSync(serverPath)) {
    console.error("ERROR: Could not find server.js");
    console.error(`Expected at: ${serverPath}`);
    process.exit(1);
  }

  console.log("[opencode-pilot] Starting polling service...");
  
  // Dynamic import of the service module
  const { startService, stopService } = await import(serverPath);
  
  const config = {
    httpPort: getPortFromConfig(),
  };
  
  const service = await startService(config);
  
  // Handle graceful shutdown
  process.on("SIGTERM", async () => {
    console.log("[opencode-pilot] Received SIGTERM, shutting down...");
    await stopService(service);
    process.exit(0);
  });
  
  process.on("SIGINT", async () => {
    console.log("[opencode-pilot] Received SIGINT, shutting down...");
    await stopService(service);
    process.exit(0);
  });
  
  // Keep running until signal received
  await new Promise(() => {});
}

// ============================================================================
// Status Command
// ============================================================================

function statusCommand() {
  console.log("opencode-pilot status");
  console.log("=====================");
  console.log("");

  // Service running? Check if HTTP responds
  const servicePort = getPortFromConfig();
  
  try {
    const res = execSync(`curl -s -o /dev/null -w "%{http_code}" http://localhost:${servicePort}/health`, { encoding: "utf8", timeout: 2000 });
    if (res.trim() === "200") {
      console.log("Service: running");
    } else {
      console.log("Service: not responding (run: opencode-pilot start)");
    }
  } catch {
    console.log("Service: not running (run: opencode-pilot start)");
  }

  // Polling configuration
  console.log("");
  console.log("Configuration:");
  if (existsSync(PILOT_CONFIG_FILE)) {
    console.log(`  config.yaml: ${PILOT_CONFIG_FILE}`);
  } else {
    console.log(`  config.yaml: not found at ${PILOT_CONFIG_FILE}`);
    console.log("  polling: disabled");
  }
}

// ============================================================================
// Config Command
// ============================================================================

async function configCommand() {
  console.log("opencode-pilot configuration");
  console.log("============================");
  console.log("");

  // Check config file exists
  if (!existsSync(PILOT_CONFIG_FILE)) {
    console.log(`Config file not found: ${PILOT_CONFIG_FILE}`);
    console.log("");
    console.log("Create one by copying the example:");
    console.log("  cp node_modules/opencode-pilot/examples/config.yaml ~/.config/opencode/pilot/config.yaml");
    process.exit(1);
  }

  // Load and parse config
  let config;
  try {
    const { default: YAML } = await import("yaml");
    const content = readFileSync(PILOT_CONFIG_FILE, "utf8");
    config = YAML.parse(content);
    console.log("✓ Config file parsed successfully");
  } catch (err) {
    console.log(`✗ Failed to parse config: ${err.message}`);
    process.exit(1);
  }

  const defaults = config.defaults || {};

  // Validate repos section
  console.log("");
  console.log("Repos:");
  const repos = config.repos || {};
  const repoKeys = Object.keys(repos);
  if (repoKeys.length === 0) {
    console.log("  (none configured)");
  } else {
    for (const key of repoKeys) {
      const repo = repos[key];
      const isPrefix = key.endsWith("/");
      const path = repo.path || repo.repo_path;
      const expandedPath = path ? path.replace("~", os.homedir()).replace("{repo}", "<repo>") : "<not set>";
      const pathExists = path && !path.includes("{repo}") ? existsSync(path.replace("~", os.homedir())) : null;
      
      if (pathExists === false) {
        console.log(`  ✗ ${key}: ${expandedPath} (path not found)`);
      } else if (isPrefix) {
        console.log(`  ${key}: ${expandedPath} (prefix)`);
      } else {
        console.log(`  ✓ ${key}: ${expandedPath}`);
      }
    }
  }

  // Validate sources section (use getSources to expand presets)
  console.log("");
  console.log("Sources:");
  const { loadRepoConfig, getSources } = await import(join(serviceDir, "repo-config.js"));
  loadRepoConfig(PILOT_CONFIG_FILE);
  
  let sources;
  try {
    sources = getSources();
  } catch (err) {
    console.log(`  ✗ Failed to load sources: ${err.message}`);
    sources = [];
  }
  
  if (sources.length === 0) {
    console.log("  (none configured)");
  } else {
    for (const source of sources) {
      const name = source.name || "<unnamed>";
      const tool = source.tool;
      
      if (!tool || !tool.mcp || !tool.name) {
        console.log(`  ✗ ${name}: missing tool.mcp or tool.name`);
        continue;
      }
      
      const itemId = source.item?.id;
      if (!itemId) {
        console.log(`  ⚠ ${name}: ${tool.mcp}/${tool.name} (no item.id template)`);
      } else {
        console.log(`  ✓ ${name}: ${tool.mcp}/${tool.name}`);
      }
      
      // Show prompt and agent
      const prompt = source.prompt || defaults.prompt || "default";
      const agent = source.agent || defaults.agent;
      console.log(`      prompt: ${prompt}`);
      if (agent) console.log(`      agent: ${agent}`);
      
      // Show repo resolution - interpolate template with configured repos
      const configuredRepos = Object.keys(config.repos || {});
      if (source.repos) {
        // Explicit repos filter - check if it's all configured repos
        const isAll = configuredRepos.length > 0 && 
          source.repos.length === configuredRepos.length &&
          source.repos.every(r => configuredRepos.includes(r));
        if (isAll) {
          console.log(`      repos: all`);
        } else {
          for (const repo of source.repos) {
            console.log(`      repo: ${repo}`);
          }
        }
      } else if (source.repo && source.repo.includes("{")) {
        // Template like {repository_full_name} - matches all configured repos
        if (configuredRepos.length > 0) {
          console.log(`      repos: all`);
        } else {
          console.log(`      repos: (none configured)`);
        }
      } else if (source.repo) {
        // Static repo
        console.log(`      repo: ${source.repo}`);
      } else if (source.working_dir) {
        console.log(`      working_dir: ${source.working_dir}`);
      }
      // Don't show working_dir if it's just the default
    }
  }

  // Validate templates
  console.log("");
  console.log("Templates:");
  if (!existsSync(PILOT_TEMPLATES_DIR)) {
    console.log(`  ⚠ Templates directory not found: ${PILOT_TEMPLATES_DIR}`);
  } else {
    const { readdirSync } = await import("fs");
    const templates = readdirSync(PILOT_TEMPLATES_DIR).filter(f => f.endsWith(".md"));
    if (templates.length === 0) {
      console.log("  (no templates found)");
    } else {
      for (const t of templates) {
        console.log(`  ✓ ${t.replace(".md", "")}`);
      }
    }
    
    // Check if referenced templates exist
    const referencedTemplates = new Set();
    if (defaults.prompt) referencedTemplates.add(defaults.prompt);
    for (const repo of Object.values(repos)) {
      if (repo.prompt) referencedTemplates.add(repo.prompt);
    }
    for (const source of sources) {
      if (source.prompt) referencedTemplates.add(source.prompt);
    }
    
    const existingTemplates = new Set(templates.map(t => t.replace(".md", "")));
    for (const ref of referencedTemplates) {
      if (!existingTemplates.has(ref)) {
        console.log(`  ✗ ${ref} (referenced but not found)`);
      }
    }
  }

  console.log("");
  console.log("Configuration valid!");
}

// ============================================================================
// Test Source Command
// ============================================================================

async function testSourceCommand(sourceName) {
  // Load sources using getSources() to expand presets
  const { loadRepoConfig, getSources } = await import(join(serviceDir, "repo-config.js"));
  loadRepoConfig(PILOT_CONFIG_FILE);
  
  let sources;
  try {
    sources = getSources();
  } catch (err) {
    console.error(`Failed to load sources: ${err.message}`);
    process.exit(1);
  }

  if (!sourceName) {
    console.error("Usage: opencode-pilot test-source <source-name>");
    console.error("");
    console.error("Available sources:");
    
    if (sources.length === 0) {
      console.error("  (no sources configured)");
    } else {
      for (const s of sources) {
        console.error(`  ${s.name}`);
      }
    }
    process.exit(1);
  }

  console.log(`Testing source: ${sourceName}`);
  console.log("=".repeat(40));
  console.log("");

  // Find source
  const source = sources.find(s => s.name === sourceName);
  
  if (!source) {
    console.error(`Source not found: ${sourceName}`);
    console.error("");
    console.error("Available sources:");
    for (const s of sources) {
      console.error(`  ${s.name}`);
    }
    process.exit(1);
  }

  // Show source config
  console.log("Source Configuration:");
  console.log(`  name: ${source.name}`);
  console.log(`  tool.mcp: ${source.tool?.mcp || "(not set)"}`);
  console.log(`  tool.name: ${source.tool?.name || "(not set)"}`);
  console.log(`  args: ${JSON.stringify(source.args || {})}`);
  console.log(`  item.id: ${source.item?.id || "(not set)"}`);
  if (source.repo) console.log(`  repo: ${source.repo}`);
  if (source.working_dir) console.log(`  working_dir: ${source.working_dir}`);
  if (source.prompt) console.log(`  prompt: ${source.prompt}`);
  if (source.agent) console.log(`  agent: ${source.agent}`);

  // Show mappings (using getToolProviderConfig which includes preset defaults)
  const { getToolProviderConfig } = await import(join(serviceDir, "repo-config.js"));
  const provider = source.tool?.mcp;
  const toolProviderConfig = getToolProviderConfig(provider);
  const mappings = toolProviderConfig?.mappings;
  
  console.log("");
  console.log("Field Mappings:");
  if (mappings && Object.keys(mappings).length > 0) {
    for (const [target, sourcePath] of Object.entries(mappings)) {
      console.log(`  ${target} ← ${sourcePath}`);
    }
  } else {
    console.log(`  (no mappings for provider '${provider}')`);
  }
  
  if (toolProviderConfig?.response_key) {
    console.log(`  response_key: ${toolProviderConfig.response_key}`);
  }

  // Fetch items
  console.log("");
  console.log("Fetching items...");
  
  try {
    // Import poller
    const pollerPath = join(serviceDir, "poller.js");
    const { pollGenericSource, applyMappings } = await import(pollerPath);
    
    // Fetch items with tool provider config (includes mappings and response_key)
    const items = await pollGenericSource(source, { toolProviderConfig });
    
    console.log(`Found ${items.length} item(s)`);
    console.log("");

    // Show first few items
    const maxItems = 3;
    for (let i = 0; i < Math.min(items.length, maxItems); i++) {
      const item = items[i];
      console.log(`Item ${i + 1}:`);
      console.log("  Raw fields:");
      for (const [key, value] of Object.entries(item)) {
        const displayValue = typeof value === "object" 
          ? JSON.stringify(value) 
          : String(value);
        const truncated = displayValue.length > 60 
          ? displayValue.substring(0, 57) + "..." 
          : displayValue;
        console.log(`    ${key}: ${truncated}`);
      }
      
      // Apply mappings
      if (mappings) {
        const mapped = applyMappings(item, mappings);
        console.log("  After mappings:");
        // Show mapped fields that are different
        for (const [target] of Object.entries(mappings)) {
          if (mapped[target] !== undefined) {
            const displayValue = typeof mapped[target] === "object"
              ? JSON.stringify(mapped[target])
              : String(mapped[target]);
            const truncated = displayValue.length > 60
              ? displayValue.substring(0, 57) + "..."
              : displayValue;
            console.log(`    ${target}: ${truncated}`);
          }
        }
      }
      console.log("");
    }

    if (items.length > maxItems) {
      console.log(`... and ${items.length - maxItems} more item(s)`);
    }

  } catch (err) {
    console.error(`Error fetching items: ${err.message}`);
    if (err.stack) {
      console.error("");
      console.error("Stack trace:");
      console.error(err.stack);
    }
    process.exit(1);
  }
}

// ============================================================================
// Test Mapping Command
// ============================================================================

async function testMappingCommand(mcpName) {
  if (!mcpName) {
    console.error("Usage: echo '<json>' | opencode-pilot test-mapping <mcp-name>");
    console.error("");
    console.error("Test field mappings by piping JSON and specifying the MCP server name.");
    console.error("");
    console.error("Example:");
    console.error('  echo \'{"url":"https://linear.app/team/issue/PROJ-123/title","title":"Fix bug"}\' | opencode-pilot test-mapping linear');
    console.error("");
    
    // Show available tools with mappings
    const { loadRepoConfig, getToolMappings } = await import(join(serviceDir, "repo-config.js"));
    loadRepoConfig(PILOT_CONFIG_FILE);
    
    console.error("Configured MCP servers with mappings:");
    for (const name of ["github", "linear"]) {
      const mappings = getToolMappings(name);
      if (mappings && Object.keys(mappings).length > 0) {
        console.error(`  ${name}:`);
        for (const [target, source] of Object.entries(mappings)) {
          console.error(`    ${target} ← ${source}`);
        }
      }
    }
    process.exit(1);
  }

  // Read JSON from stdin
  const chunks = [];
  for await (const chunk of process.stdin) {
    chunks.push(chunk);
  }
  const input = Buffer.concat(chunks).toString().trim();
  
  if (!input) {
    console.error("Error: No JSON input provided. Pipe JSON to stdin.");
    console.error("");
    console.error("Example:");
    console.error('  echo \'{"url":"https://linear.app/team/issue/PROJ-123/title"}\' | opencode-pilot test-mapping linear');
    process.exit(1);
  }

  let item;
  try {
    item = JSON.parse(input);
  } catch (err) {
    console.error(`Error parsing JSON: ${err.message}`);
    process.exit(1);
  }

  // Load mappings
  const { loadRepoConfig, getToolMappings } = await import(join(serviceDir, "repo-config.js"));
  const { applyMappings } = await import(join(serviceDir, "poller.js"));
  
  loadRepoConfig(PILOT_CONFIG_FILE);
  const mappings = getToolMappings(mcpName);

  if (!mappings || Object.keys(mappings).length === 0) {
    console.error(`No mappings configured for MCP server: ${mcpName}`);
    console.error("");
    console.error("Add mappings to your config.yaml:");
    console.error("  tools:");
    console.error(`    ${mcpName}:`);
    console.error("      mappings:");
    console.error('        number: "url:/([A-Z0-9]+-[0-9]+)/"');
    process.exit(1);
  }

  console.log("Input:");
  for (const [key, value] of Object.entries(item)) {
    const displayValue = typeof value === "object" ? JSON.stringify(value) : String(value);
    const truncated = displayValue.length > 60 ? displayValue.substring(0, 57) + "..." : displayValue;
    console.log(`  ${key}: ${truncated}`);
  }
  console.log("");

  console.log(`Mappings (${mcpName}):`);
  for (const [target, source] of Object.entries(mappings)) {
    console.log(`  ${target} ← ${source}`);
  }
  console.log("");

  const mapped = applyMappings(item, mappings);

  console.log("Result:");
  for (const [target] of Object.entries(mappings)) {
    const value = mapped[target];
    if (value !== undefined) {
      console.log(`  ${target}: ${value}`);
    } else {
      console.log(`  ${target}: (undefined - no match)`);
    }
  }
}

// ============================================================================
// Clear Command
// ============================================================================

async function clearCommand(flags) {
  try {
    const { createPoller } = await import(join(serviceDir, "poller.js"));
    const { loadRepoConfig, getCleanupTtlDays } = await import(join(serviceDir, "repo-config.js"));
    
    // Load config for TTL settings
    if (existsSync(PILOT_CONFIG_FILE)) {
      loadRepoConfig(PILOT_CONFIG_FILE);
    }
    
    const poller = createPoller();
    const beforeCount = poller.getProcessedCount();
    
    if (flags.all) {
      poller.clearState();
      console.log(`Cleared all ${beforeCount} processed entries`);
    } else if (flags.source) {
      const removed = poller.clearBySource(flags.source);
      console.log(`Cleared ${removed} entries for source: ${flags.source}`);
    } else if (flags.item) {
      if (poller.isProcessed(flags.item)) {
        poller.clearProcessed(flags.item);
        console.log(`Cleared item: ${flags.item}`);
      } else {
        console.log(`Item not found in processed state: ${flags.item}`);
      }
    } else if (flags.expired) {
      const ttlDays = getCleanupTtlDays();
      const removed = poller.cleanupExpired(ttlDays);
      console.log(`Cleared ${removed} entries older than ${ttlDays} days`);
    } else {
      // No flags - show current state summary
      console.log("Poll state summary:");
      console.log(`  Total entries: ${beforeCount}`);
      console.log(`  State file: ~/.config/opencode/pilot/poll-state.json`);
      console.log("");
      console.log("Usage:");
      console.log("  opencode-pilot clear --all           Clear all entries");
      console.log("  opencode-pilot clear --source NAME   Clear entries for source");
      console.log("  opencode-pilot clear --item ID       Clear specific item");
      console.log("  opencode-pilot clear --expired       Clear expired entries");
    }
  } catch (err) {
    console.error(`Error: ${err.message}`);
    console.error("The state file may be corrupted. Try: opencode-pilot clear --all");
    process.exit(1);
  }
}

// ============================================================================
// Main
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  const { command, subcommand } = parseArgs(args);

  if (!command || command === "help") {
    showHelp();
    return;
  }

  switch (command) {
    case "start":
      await startCommand();
      break;

    case "status":
      statusCommand();
      break;

    case "config":
      await configCommand();
      break;

    case "clear":
      await clearCommand(parseArgs(args).flags);
      break;

    case "test-source":
      await testSourceCommand(subcommand);
      break;

    case "test-mapping":
      await testMappingCommand(subcommand);
      break;

    default:
      console.error(`Unknown command: ${command}`);
      console.error("");
      showHelp();
      process.exit(1);
  }
}

main().catch((err) => {
  console.error("Error:", err.message);
  process.exit(1);
});
